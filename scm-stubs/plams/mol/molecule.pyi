import sys
from os import PathLike
from abc import abstractmethod
from typing import (
    Sized,
    List,
    Any,
    Union,
    Iterable,
    Optional,
    Collection,
    Sequence,
    Tuple,
    Dict,
    Callable,
    TextIO,
    Iterator,
    overload,
)

import numpy as np
from scm.plams import Atom, Bond, PDBHandler, Settings

if sys.version_info >= (3, 8):
    from typing import Literal, SupportsIndex, TypedDict
else:
    from typing_extensions import Literal, Protocol, TypedDict
    class SupportsIndex(Protocol):
        @abstractmethod
        def __index__(self) -> int:
            pass

Vector = Tuple[float, float, float]
Matrix = Tuple[Vector, Vector, Vector]

class AtomDict(TypedDict):
    atnum: int
    bonds: List[int]
    coords: Tuple[float, float, float]
    properties: Settings[Any, Any]

class BondDict(TypedDict):
    atom1: int
    atom2: int
    order: float
    properties: Settings[Any, Any]

class _MolDict(TypedDict, total=False):
    charge: int

class MolDict(_MolDict):
    atoms: List[AtomDict]
    bonds: List[BondDict]
    lattice: List[Vector]
    properties: Settings[Any, Any]

class LabelDict(TypedDict, total=False):
    BO: bool
    RS: bool
    EZ: bool
    DH: bool
    CO: bool
    twist_tol: float
    bend_tol: float

ValidFormats = Literal["xyz", "pdb", "mol", "mol2", "rkf"]

class Molecule:
    atoms: List[Atom]
    bonds: List[Bond]
    lattice: List[Vector]
    properties: Settings[Any, Any]
    def __init__(
        self,
        filename: Union[None, str, PathLike[str]] = ...,
        inputformat: Optional[ValidFormats] = ...,
        **other: Any
    ) -> None: ...
    def copy(self, atoms: Optional[Collection[Atom]] = ...) -> Molecule: ...
    def add_molecule(self, other: Molecule, copy: bool = ...) -> None: ...
    def add_atom(
        self, atom: Atom, adjacent: Optional[Iterable[Atom]] = ...
    ) -> None: ...
    def delete_atom(self, atom: Atom) -> None: ...
    @overload
    def add_bond(self, arg1: Atom, arg2: Atom, order: float = ...) -> None: ...
    @overload
    def add_bond(self, arg1: Bond, arg2: None = ..., order: float = ...) -> None: ...
    @overload
    def delete_bond(self, arg1: Atom, arg2: Atom) -> None: ...
    @overload
    def delete_bond(self, arg1: Bond, arg2: None = ...) -> None: ...
    def delete_all_bonds(self) -> None: ...
    def find_bond(self, atom1: Atom, atom2: Atom) -> Optional[Bond]: ...
    def set_atoms_id(self, start: int = ...) -> None: ...
    def unset_atoms_id(self) -> None: ...
    def neighbors(self, atom: Atom) -> List[Atom]: ...
    def bond_matrix(self) -> np.ndarray: ...
    def separate(self) -> List[Molecule]: ...
    def guess_bonds(
        self, atom_subset: Optional[Sequence[Atom]] = ..., dmax: float = ...
    ) -> None: ...
    def in_ring(self, arg: Union[Atom, Bond]) -> bool: ...
    def supercell(self, *args: Vector) -> Molecule: ...
    def unit_cell_volume(self, unit: str = ...) -> float: ...
    def set_integer_bonds(self, action: str = ..., tolerance: float = ...) -> None: ...
    @overload
    def index(
        self, value: Atom, start: int = ..., stop: Optional[int] = ...
    ) -> int: ...
    @overload
    def index(
        self, value: Bond, start: int = ..., stop: Optional[int] = ...
    ) -> Tuple[int, int]: ...
    @overload
    def round_coords(  # type: ignore[misc]
        self, decimals: int = ..., inplace: Literal[False] = ...
    ) -> Molecule: ...
    @overload
    def round_coords(
        self, decimals: int = ..., inplace: Literal[True] = ...
    ) -> None: ...
    def translate(
        self, vector: Tuple[float, float, float], unit: str = ...
    ) -> None: ...
    def rotate_lattice(self, matrix: Matrix) -> None: ...
    def rotate(self, matrix: Matrix, lattice: bool = ...) -> None: ...
    def align_lattice(self, convention: str = ..., zero: float = ...) -> bool: ...
    def rotate_bond(
        self, bond: Bond, moving_atom: Atom, angle: float, unit: str = ...
    ) -> None: ...
    def resize_bond(
        self, bond: Bond, moving_atom: Atom, length: float, unit: str = ...
    ) -> None: ...
    def closest_atom(self, point: Union[Atom, Vector], unit: str = ...) -> Atom: ...
    def distance_to_point(
        self, point: Vector, unit: str = ..., result_unit: str = ...
    ) -> float: ...
    @overload
    def distance_to_mol(  # type: ignore[misc]
        self,
        other: Molecule,
        result_unit: str = ...,
        return_atoms: Literal[False] = ...,
    ) -> float: ...
    @overload
    def distance_to_mol(
        self, other: Molecule, result_unit: str = ..., return_atoms: Literal[True] = ...
    ) -> Tuple[float, Atom, Atom]: ...
    def wrap(
        self,
        length: float,
        angle: float = ...,
        length_unit: str = ...,
        angle_unit: str = ...,
    ) -> None: ...
    def get_center_of_mass(self, unit: str = ...) -> Vector: ...
    def get_mass(self) -> float: ...
    @overload
    def get_formula(self, as_dict: Literal[False] = ...) -> str: ...
    @overload
    def get_formula(self, as_dict: Literal[True]) -> Dict[str, int]: ...
    def apply_strain(
        self, strain: Union[np.ndarray, Sequence[float]], voigt_form: bool = ...
    ) -> None: ...
    def perturb_atoms(
        self,
        max_displacement: float = ...,
        unit: str = ...,
        atoms: Optional[Iterable[Atom]] = ...,
    ) -> None: ...
    def perturb_lattice(
        self, max_displacement: float = ..., unit: str = ..., ams_convention: bool = ...
    ) -> None: ...
    def substitute(
        self,
        connector: Union[Bond, Tuple[Atom, Atom]],
        ligand: Molecule,
        ligand_connector: Union[Bond, Tuple[Atom, Atom]],
        bond_length: Optional[float] = ...,
        steps: int = ...,
        cost_func_mol: Optional[Callable[[Molecule, Molecule], float]] = ...,
        cost_func_array: Optional[Callable[[np.ndarray, np.ndarray], float]] = ...,
    ) -> None: ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
    def __iter__(self) -> Iterator[Atom]: ...
    @overload
    def __getitem__(self, key: SupportsIndex) -> Atom: ...
    @overload
    def __getitem__(self, key: Tuple[SupportsIndex, SupportsIndex]) -> Bond: ...
    def __add__(self, other: Molecule) -> Molecule: ...
    def __iadd__(self, other: Molecule) -> Molecule: ...
    def __copy__(self) -> Molecule: ...
    def __round__(self, ndigits: Optional[int] = ...) -> Molecule: ...
    def as_dict(self) -> MolDict: ...
    @classmethod
    def from_dict(cls, dictionary: MolDict) -> Molecule: ...
    @classmethod
    def from_elements(cls, elements: Iterable[str]) -> Molecule: ...
    def as_array(self, atom_subset: Optional[Iterable[Atom]] = ...) -> np.ndarray: ...
    def from_array(
        self,
        xyz_array: Union[Molecule, Iterable[Tuple[float, float, float]]],
        atom_subset: Optional[Iterable[Atom]] = ...,
    ) -> None: ...
    def __array__(self, dtype: Any = ...) -> np.ndarray: ...
    def readxyz(self, f: TextIO, geometry: int = ..., **other: Any) -> None: ...
    def writexyz(self, f: TextIO, **other: Any) -> None: ...
    def readmol(self, f: TextIO, **other: Any) -> None: ...
    def writemol(self, f: TextIO, **other: Any) -> None: ...
    def readmol2(self, f: TextIO, **other: Any) -> None: ...
    def writemol2(self, f: TextIO, **other: Any) -> None: ...
    def readpdb(self, f: TextIO, geometry: int = ..., **other: Any) -> PDBHandler: ...
    def writepdb(self, f: TextIO, **other: Any) -> None: ...
    def read(
        self,
        filename: Union[str, PathLike[str]],
        inputformat: Optional[str] = ...,
        **other: Any
    ) -> Optional[PDBHandler]: ...
    def write(
        self,
        filename: Union[str, PathLike[str]],
        outputformat: Optional[str] = ...,
        **other: Any
    ) -> None: ...
    # `label` and `reorder` are defined in `scm.plams.mol.identity`
    @overload
    def label(
        self,
        level: int = ...,
        keep_labels: bool = ...,
        flags: Optional[LabelDict] = ...,
    ) -> str: ...
    @overload
    def label(
        self,
        level: Sequence[int],
        keep_labels: bool = ...,
        flags: Optional[LabelDict] = ...,
    ) -> Tuple[str, ...]: ...
    def reorder(self, other: Molecule) -> None: ...
