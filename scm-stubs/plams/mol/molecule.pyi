import os
import sys
from collections.abc import Callable, Collection, Iterable, Iterator, Sequence, Sized
from typing import IO, Any, overload

import numpy as np
from scm.plams import Atom, Bond, PDBHandler, Settings

if sys.version_info >= (3, 8):
    from typing import Literal as L, SupportsIndex, TypedDict
else:
    from typing_extensions import Literal as L, SupportsIndex, TypedDict

class _AtomDict(TypedDict):
    atnum: int
    bonds: list[int]
    coords: tuple[float, float, float]
    properties: Settings[Any, Any]

class _BondDict(TypedDict):
    atom1: int
    atom2: int
    order: float
    properties: Settings[Any, Any]

class _MolDictBase(TypedDict, total=False):
    charge: int

class _MolDict(_MolDictBase):
    atoms: list[_AtomDict]
    bonds: list[_BondDict]
    lattice: list[Sequence[float]]
    properties: Settings[Any, Any]

class _LabelDict(TypedDict, total=False):
    BO: bool
    RS: bool
    EZ: bool
    DH: bool
    CO: bool
    twist_tol: float
    bend_tol: float

class Molecule:
    atoms: list[Atom]
    bonds: list[Bond]
    lattice: list[Sequence[float]]
    properties: Settings[Any, Any]
    def __init__(
        self,
        filename: None | str | os.PathLike[str] = ...,
        inputformat: L[None, "xyz", "pdb", "mol", "mol2", "rkf"] = ...,
        **other: Any,
    ) -> None: ...
    def copy(self, atoms: None | Collection[Atom] = ...) -> Molecule: ...
    def add_molecule(self, other: Molecule, copy: bool = ...) -> None: ...
    def add_atom(self, atom: Atom, adjacent: None | Iterable[Atom] = ...) -> None: ...
    def delete_atom(self, atom: Atom) -> None: ...
    @overload
    def add_bond(self, arg1: Atom, arg2: Atom, order: float = ...) -> None: ...
    @overload
    def add_bond(self, arg1: Bond, arg2: None = ..., order: float = ...) -> None: ...
    @overload
    def delete_bond(self, arg1: Atom, arg2: Atom) -> None: ...
    @overload
    def delete_bond(self, arg1: Bond, arg2: None = ...) -> None: ...
    def delete_all_bonds(self) -> None: ...
    def find_bond(self, atom1: Atom, atom2: Atom) -> None | Bond: ...
    def set_atoms_id(self, start: int = ...) -> None: ...
    def unset_atoms_id(self) -> None: ...
    def neighbors(self, atom: Atom) -> list[Atom]: ...
    def bond_matrix(self) -> np.ndarray: ...
    def separate(self) -> list[Molecule]: ...
    def guess_bonds(self, atom_subset: None | Sequence[Atom] = ..., dmax: float = ...) -> None: ...
    def in_ring(self, arg: Atom | Bond) -> bool: ...
    def supercell(self, *args: Sequence[float]) -> Molecule: ...
    def unit_cell_volume(self, unit: str = ...) -> float: ...
    def set_integer_bonds(self, action: str = ..., tolerance: float = ...) -> None: ...
    @overload
    def index(self, value: Atom, start: int = ..., stop: None | int = ...) -> int: ...
    @overload
    def index(self, value: Bond, start: int = ..., stop: None | int = ...) -> tuple[int, int]: ...
    @overload
    def round_coords(self, decimals: int = ..., inplace: L[False] = ...) -> Molecule: ...  # type: ignore[misc]
    @overload
    def round_coords(self, decimals: int = ..., inplace: L[True] = ...) -> None: ...
    def translate(self, vector: tuple[float, float, float], unit: str = ...) -> None: ...
    def rotate_lattice(self, matrix: Sequence[Sequence[float]] | np.ndarray) -> None: ...
    def rotate(self, matrix: Sequence[Sequence[float]] | np.ndarray, lattice: bool = ...) -> None: ...
    def align_lattice(self, convention: str = ..., zero: float = ...) -> bool: ...
    def rotate_bond(self, bond: Bond, moving_atom: Atom, angle: float, unit: str = ...) -> None: ...
    def resize_bond(self, bond: Bond, moving_atom: Atom, length: float, unit: str = ...) -> None: ...
    def closest_atom(self, point: Atom | tuple[float, float, float], unit: str = ...) -> Atom: ...
    def distance_to_point(self, point: Sequence[float], unit: str = ..., result_unit: str = ...) -> float: ...
    @overload
    def distance_to_mol(  # type: ignore[misc]
        self, other: Molecule, result_unit: str = ..., return_atoms: L[False] = ...
    ) -> float: ...
    @overload
    def distance_to_mol(
        self, other: Molecule, result_unit: str = ..., return_atoms: L[True] = ...
    ) -> tuple[float, Atom, Atom]: ...
    def wrap(self, length: float, angle: float = ..., length_unit: str = ..., angle_unit: str = ...) -> None: ...
    def get_center_of_mass(self, unit: str = ...) -> tuple[float, float, float]: ...
    def get_mass(self) -> float: ...
    @overload
    def get_formula(self, as_dict: L[False] = ...) -> str: ...
    @overload
    def get_formula(self, as_dict: L[True]) -> dict[str, int]: ...
    def apply_strain(self, strain: np.ndarray | Sequence[float], voigt_form: bool = ...) -> None: ...
    def perturb_atoms(self, max_displacement: float = ..., unit: str = ..., atoms: None | Iterable[Atom] = ...) -> None: ...
    def perturb_lattice(self, max_displacement: float = ..., unit: str = ..., ams_convention: bool = ...) -> None: ...
    def substitute(
        self,
        connector: Bond | tuple[Atom, Atom],
        ligand: Molecule,
        ligand_connector: Bond | tuple[Atom, Atom],
        bond_length: None | float = ...,
        steps: int = ...,
        cost_func_mol: None | Callable[[Molecule, Molecule], float] = ...,
        cost_func_array: None | Callable[[np.ndarray, np.ndarray], float] = ...,
    ) -> None: ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
    def __iter__(self) -> Iterator[Atom]: ...
    @overload
    def __getitem__(self, key: SupportsIndex) -> Atom: ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex, SupportsIndex]) -> Bond: ...
    def __add__(self, other: Molecule) -> Molecule: ...
    def __iadd__(self, other: Molecule) -> Molecule: ...
    def __copy__(self) -> Molecule: ...
    def __round__(self, ndigits: None | int = ...) -> Molecule: ...
    def as_dict(self) -> _MolDict: ...
    @classmethod
    def from_dict(cls, dictionary: _MolDict) -> Molecule: ...
    @classmethod
    def from_elements(cls, elements: Iterable[str]) -> Molecule: ...
    def as_array(self, atom_subset: None | Iterable[Atom] = ...) -> np.ndarray: ...
    def from_array(
        self, xyz_array: Molecule | Iterable[tuple[float, float, float]] | np.ndarray, atom_subset: None | Iterable[Atom] = ...
    ) -> None: ...
    def __array__(self, dtype: Any = ...) -> np.ndarray: ...
    def readxyz(self, f: IO[str], geometry: int = ..., **other: Any) -> None: ...
    def writexyz(self, f: IO[str], **other: Any) -> None: ...
    def readmol(self, f: IO[str], **other: Any) -> None: ...
    def writemol(self, f: IO[str], **other: Any) -> None: ...
    def readmol2(self, f: IO[str], **other: Any) -> None: ...
    def writemol2(self, f: IO[str], **other: Any) -> None: ...
    def readpdb(self, f: IO[str], geometry: int = ..., **other: Any) -> PDBHandler: ...
    def writepdb(self, f: IO[str], **other: Any) -> None: ...
    def read(self, filename: str | os.PathLike[str], inputformat: None | str = ..., **other: Any) -> None | PDBHandler: ...
    def write(self, filename: str | os.PathLike[str], outputformat: None | str = ..., **other: Any) -> None: ...
    # `label` and `reorder` are defined in `scm.plams.mol.identity`
    @overload
    def label(self, level: int = ..., keep_labels: bool = ..., flags: None | _LabelDict = ...) -> str: ...
    @overload
    def label(self, level: Sequence[int], keep_labels: bool = ..., flags: None | _LabelDict = ...) -> tuple[str, ...]: ...
    def reorder(self, other: Molecule) -> None: ...
