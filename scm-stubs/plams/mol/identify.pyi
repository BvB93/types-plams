from collections.abc import Collection, Iterable, Mapping, Sequence
from typing import Any, TypeVar

import numpy.typing as npt
from scm.plams import Atom, Bond, Molecule

_MT = TypeVar("_MT", bound="Collection[Atom]")

possible_flags: list[str]

def twist(v1: npt.ArrayLike, v2: npt.ArrayLike, v3: npt.ArrayLike, tolerance: float | None = ...) -> tuple[int, None | int]: ...
def bend(v1: npt.ArrayLike, v2: npt.ArrayLike, tolerance: float | None = ...) -> int: ...
def unique_atoms(atomlist: Collection[Atom]) -> list[Atom]: ...
def initialize(molecule: Iterable[Atom]) -> None: ...
def clear(molecule: Iterable[Atom]) -> None: ...
def iterate(molecule: Collection[Atom], flags: Mapping[str, Any]) -> bool: ...
def new_name(atom: Atom, flags: Mapping[str, Any]) -> str: ...
def knock(A: Atom, bond: Bond, flags: Mapping[str, Any]) -> tuple[str, Atom]: ...
def label_atoms(molecule: _MT, **kwargs: Any) -> _MT: ...
def molecule_name(molecule: Iterable[Atom]) -> str: ...
def label(self: Molecule, level: int = ..., keep_labels: bool = ..., flags: None | Mapping[str, Any] = ...) -> str: ...
def set_local_labels(self: Molecule, niter: int = ..., flags: None | Mapping[str, Any] = ...) -> None: ...
def find_permutation(molecule1: Molecule, molecule2: Molecule) -> None: ...
def reorder(self: Molecule, other: Molecule) -> None | list[Atom]: ...
