import os
import sys
from collections.abc import Iterator
from typing import Any, overload

import numpy as np
import numpy.typing as npt
from scm.plams import Job, JobManager, JobRunner, KFFile, Molecule, Results, Settings, SingleJob

if sys.version_info >= (3, 8):
    from typing import Literal as L, TypedDict
else:
    from typing_extensions import Literal as L, TypedDict

class _TimingsDict(TypedDict):
    elapsed: float
    system: float
    cpu: float

class _PESScanDict(TypedDict):
    RaveledScanCoords: list[str]
    nRaveledScanCoords: int
    ScanCoords: list[list[str]]
    nScanCoords: int
    OrigScanCoords: list[str]
    RaveledPESCoords: list[list[str]]
    Units: list[list[str]]
    RaveledUnits: list[str]
    Converged: list[bool]
    PES: list[float]
    nPESPoints: int
    HistoryIndices: list[int]

class _PESScanDictMol(_PESScanDict):
    Molecules: list[Molecule]

class _State:
    engfile: str
    energy: float
    molecule: Molecule
    count: int
    isTS: bool
    reactantsID: None | int
    productsID: None | int
    def __init__(
        self,
        landscape: _EnergyLandscape,
        engfile: str,
        energy: float,
        mol: Molecule,
        count: int,
        isTS: bool,
        reactantsID: None | int = ...,
        productsID: None | int = ...,
    ) -> None: ...
    @property
    def id(self) -> int: ...
    @property
    def reactants(self) -> _State: ...
    @property
    def products(self) -> _State: ...
    def __str__(self) -> str: ...

class _EnergyLandscape:
    def __init__(self, results: AMSResults) -> None: ...
    @property
    def minima(self) -> list[_State]: ...
    @property
    def transition_states(self) -> list[_State]: ...
    def __str__(self) -> str: ...
    def __getitem__(self, i: int) -> _State: ...
    def __iter__(self) -> Iterator[_State]: ...
    def __len__(self) -> int: ...
    State = _State

class AMSResults(Results):
    EnergyLandscape = _EnergyLandscape
    rkfs: dict[str, KFFile]
    job: AMSJob
    def __init__(self, job: AMSJob) -> None: ...
    def collect(self) -> None: ...
    def refresh(self) -> None: ...
    def engine_names(self) -> list[str]: ...
    def rkfpath(self, file: str = ...) -> str: ...
    def readrkf(self, section: str, variable: str, file: str = ...) -> Any: ...
    def read_rkf_section(self, section: str, file: str = ...) -> dict[str, Any]: ...
    def get_rkf_skeleton(self, file: str = ...) -> dict[str, set[str]]: ...
    def get_molecule(self, section: str, file: str = ...) -> Molecule: ...
    def get_input_molecule(self) -> Molecule: ...
    def get_main_molecule(self) -> Molecule: ...
    def get_history_molecule(self, step: int) -> Molecule: ...
    def get_history_variables(self, history_section: str = ...) -> set[str]: ...
    def get_history_property(self, varname: str, history_section: str = ...) -> list[Any]: ...
    def get_property_at_step(self, step: int, varname: str, history_section: str = ...) -> Any: ...
    def get_engine_results(self, engine: None | str = ...) -> dict[str, Any]: ...
    def get_engine_properties(self, engine: None | str = ...) -> dict[str, Any]: ...
    def get_energy(self, unit: str = ..., engine: None | str = ...) -> float: ...
    def get_gradients(
        self, energy_unit: str = ..., dist_unit: str = ..., engine: None | str = ...
    ) -> npt.NDArray[np.float64]: ...
    def get_stresstensor(self, engine: None | str = ...) -> npt.NDArray[np.float64]: ...
    def get_hessian(self, engine: None | str = ...) -> npt.NDArray[np.float64]: ...
    def get_elastictensor(self, engine: None | str = ...) -> npt.NDArray[np.float64]: ...
    def get_frequencies(self, unit: str = ..., engine: None | str = ...) -> npt.NDArray[np.float64]: ...
    def get_charges(self, engine: None | str = ...) -> npt.NDArray[np.float64]: ...
    def get_dipolemoment(self, engine: None | str = ...) -> npt.NDArray[np.float64]: ...
    def get_dipolegradients(self, engine: None | str = ...) -> npt.NDArray[np.float64]: ...
    def get_timings(self) -> _TimingsDict: ...
    def get_youngmodulus(self, unit: str = ..., engine: None | str = ...) -> float: ...
    def get_shearmodulus(self, unit: str = ..., engine: None | str = ...) -> float: ...
    def get_bulkmodulus(self, unit: str = ..., engine: None | str = ...) -> float: ...
    @overload
    def get_pesscan_results(self, molecules: L[True] = ...) -> _PESScanDictMol: ...
    @overload
    def get_pesscan_results(self, molecules: L[False]) -> _PESScanDict: ...
    def recreate_molecule(self) -> None | Molecule: ...
    def recreate_settings(self) -> None | Settings: ...
    def ok(self) -> bool: ...
    def get_errormsg(self) -> str: ...
    @property
    def name(self) -> str: ...
    def get_energy_landscape(self) -> _EnergyLandscape: ...

class AMSJob(SingleJob):
    results: AMSResults
    def run(self, jobrunner: None | JobRunner[Any] = ..., jobmanager: None | JobManager = ..., **kwargs: Any) -> AMSResults: ...
    def get_input(self) -> str: ...
    def get_runscript(self) -> str: ...
    def check(self) -> bool: ...
    def get_errormsg(self) -> str: ...
    def hash_input(self) -> str: ...
    def get_task(self) -> None | str: ...
    @classmethod
    def load_external(
        cls, path: str | os.PathLike[str], settings: None | Settings = ..., molecule: None | Molecule = ..., finalize: bool = ...
    ) -> AMSJob: ...
    @classmethod
    def from_inputfile(
        cls, filename: str | os.PathLike[str], heredoc_delimit: str = ..., *, name: str = ..., depend: None | list[Job] = ...
    ) -> AMSJob: ...
    @staticmethod
    def settings_to_mol(s: Settings) -> dict[str, Molecule]: ...
    @staticmethod
    def _slurm_env(settings: Settings) -> str: ...
